<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drip Drip - Loop Music Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .timeline {
            width: 80%;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0;
            margin-bottom: 40px;
            position: relative;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .timeline-grid {
            width: 100%;
            height: 100%;
            display: flex;
        }

        .timeline-beat {
            flex: 1;
            border-right: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            display: flex;
        }

        .timeline-beat:last-child {
            border-right: none;
        }

        .timeline-beat.active {
            background: rgba(0, 255, 255, 0.3);
        }

        .timeline-subdivision {
            flex: 1;
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            position: relative;
        }

        .timeline-subdivision:last-child {
            border-right: none;
        }

        .timeline-beat-number {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            z-index: 2;
        }

        .timeline-subdivision.active {
            background: rgba(0, 255, 255, 0.2);
        }

        .droplet-marker {
            position: absolute;
            top: 0;
            width: 1.5625%; /* 100% / 64 positions */
            height: 100%;
            background: #00ffff;
            border-radius: 0;
            transform: translateX(-50%);
            pointer-events: auto;
            cursor: grab;
            transition: none;
            box-shadow: inset 1px 1px 2px rgba(255, 255, 255, 0.5), inset -1px -1px 2px rgba(0, 0, 0, 0.3);
        }

        .droplet-marker.selected {
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        .droplet-marker:hover {
            background: #00cccc;
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
            transition: all 0.2s ease;
        }

        .droplet-marker:active {
            cursor: grabbing;
            transform: translateX(-50%) scale(1.2);
            transition: none;
        }

        .basin {
            width: 480px;
            height: 480px;
            border: 2px solid #005a7a;
            border-radius: 50%;
            position: relative;
            background: radial-gradient(circle, rgba(5, 15, 25, 0.8) 0%, rgba(0, 80, 120, 0.5) 75%, rgba(0, 180, 220, 0.3) 98%);
            cursor: crosshair;
            overflow: hidden;
            box-shadow: inset 0px 10px 25px rgba(0, 0, 0, 0.5), 
                        inset 0px -10px 25px rgba(255, 255, 255, 0.1),
                        0 0 15px rgba(0, 180, 220, 0.3);
        }

        .basin-ripple {
            position: absolute;
            border: 1px solid white;
            border-radius: 50%;
            pointer-events: none;
            width: 2px;
            height: 2px;
            transform: translate(-50%, -50%);
            animation: basinRipple 1.2s ease-out forwards;
            background: transparent;
            z-index: 1;
        }

        @keyframes basinRipple {
            from {
                transform: translate(-50%, -50%) scale(1);
            }
            to {
                transform: translate(-50%, -50%) scale(150);
                opacity: 0;
            }
        }

        .droplet {
            position: absolute;
            width: 15px;
            height: 15px;
            background: #0088ff;
            border-radius: 50%;
            cursor: grab;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: box-shadow 0.2s ease;
            z-index: 10;
        }

        .droplet:hover {
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }

        .droplet:active {
            cursor: grabbing;
        }

        .droplet.selected {
            border: 2px solid white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .controls {
            margin-top: 30px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .play-button {
            padding: 12px 24px;
            background: #00ffff;
            color: #000;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .play-button:hover {
            background: #00cccc;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.3);
        }

        .play-button:active {
            transform: translateY(0);
        }

        .play-button.playing {
            background: #ff4444;
        }

        .play-button.playing:hover {
            background: #cc3333;
        }

        .info {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            margin-top: 20px;
        }

        .parameter-menu {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            min-width: 250px;
            display: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .parameter-menu.visible {
            display: block;
        }

        .parameter-menu h3 {
            color: #00ffff;
            margin: 0 0 15px 0;
            font-size: 16px;
            text-align: center;
        }

        .parameter-group {
            margin-bottom: 20px;
        }

        .parameter-group label {
            display: block;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
            font-size: 14px;
        }

        .parameter-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .parameter-group input[type="number"] {
            width: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            text-align: center;
        }

        .parameter-group select {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px;
            border-radius: 4px;
        }

        .parameter-group select option {
            background: #000;
        }

        .menu-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #00ffff;
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-close:hover {
            color: #ff4444;
        }

        .velocity-display {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            text-align: center;
            margin-top: 5px;
        }

        .ghost-marker {
            position: absolute;
            top: 0;
            width: 1.5625%; /* 100% / 64 positions */
            height: 100%;
            background: rgba(0, 255, 255, 0.3);
            border-radius: 0;
            transform: translateX(-50%);
            pointer-events: none;
            border: none;
            box-shadow: inset 1px 1px 2px rgba(255, 255, 255, 0.4), inset -1px -1px 2px rgba(0, 0, 0, 0.2);
        }

        .cave-mode-button {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            font-size: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: lowercase;
            font-family: monospace;
        }

        .cave-mode-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.6);
        }

        .cave-mode-button.active {
            background: rgba(0, 90, 122, 0.8);
            color: rgba(0, 255, 255, 0.8);
            border-color: rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="timeline" id="timeline">
            <div class="timeline-grid" id="timelineGrid"></div>
        </div>
        
        <div class="basin" id="basin">
            <!-- Droplets will be added here dynamically -->
        </div>
        
        <div class="controls">
            <button class="play-button" id="playButton">Play</button>
        </div>
        
        <div class="info">
            Click timeline or basin to place droplets • Drag in basin to adjust pitch • Center = low, rim = high
        </div>

        <button class="cave-mode-button" id="caveModeButton">cave mode</button>

        <div class="parameter-menu" id="parameterMenu">
            <button class="menu-close" id="menuClose">×</button>
            <h3>Droplet Parameters</h3>
            
            <div class="parameter-group">
                <label for="velocitySlider">Velocity</label>
                <input type="range" id="velocitySlider" min="0.1" max="1.0" step="0.1" value="0.7">
                <div class="velocity-display" id="velocityDisplay">70%</div>
            </div>
            
            <div class="parameter-group">
                <label for="repeatSelect">Repeat Pattern</label>
                <select id="repeatSelect">
                    <option value="none">No Repeat</option>
                    <option value="every-beat">Every Beat</option>
                    <option value="every-2-beats">Every 2 Beats</option>
                    <option value="every-4-beats">Every 4 Beats</option>
                    <option value="custom">Custom...</option>
                </select>
            </div>
            
            <div class="parameter-group" id="customRepeatGroup" style="display: none;">
                <label for="customRepeatInput">Custom Repeat (beats)</label>
                <input type="number" id="customRepeatInput" min="1" max="32" value="4">
            </div>
        </div>
    </div>

    <script>
        class DripDrip {
            constructor() {
                this.audioContext = null;
                this.isPlaying = false;
                this.isCaveMode = false;
                this.currentPosition = 0;
                this.beatsPerLoop = 4;
                this.subdivisionsPerBeat = 16;
                this.totalPositions = this.beatsPerLoop * this.subdivisionsPerBeat; // 64
                this.bpm = 120;
                this.droplets = [];
                this.nextNoteTime = 0;
                this.scheduler = null;
                
                // Action history for undo functionality
                this.actionHistory = [];
                this.maxHistorySize = 50;
                
                // Global dragging state
                this.isDraggingMarker = false;
                
                this.initAudio();
                this.initTimeline();
                this.initBasin();
                this.initControls();
            }

            createNoiseBuffer() {
                const bufferSize = this.audioContext.sampleRate;
                const buffer = this.audioContext.createBuffer(1, bufferSize, bufferSize);
                const output = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }

                return buffer;
            }

            createReverbImpulseResponse() {
                const duration = 2.5;
                const decay = 3.0;
                const sampleRate = this.audioContext.sampleRate;
                const length = sampleRate * duration;
                const impulse = this.audioContext.createBuffer(2, length, sampleRate); // Stereo
                const impulseL = impulse.getChannelData(0);
                const impulseR = impulse.getChannelData(1);

                for (let i = 0; i < length; i++) {
                    const n = length - i;
                    impulseL[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
                    impulseR[i] = (Math.random() * 2 - 1) * Math.pow(n / length, decay);
                }
                return impulse;
            }

            initAudio() {
                // Initialize Web Audio API
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // --- Master Reverb Effect ---
                this.masterInput = this.audioContext.createGain();
                
                // Dry path
                const dryGain = this.audioContext.createGain();
                dryGain.gain.value = 1.0;
                this.masterInput.connect(dryGain);
                dryGain.connect(this.audioContext.destination);

                // Wet path (Reverb) - start with reverb off
                this.reverbWetGain = this.audioContext.createGain();
                this.reverbWetGain.gain.value = 0.0;
                const reverbNode = this.audioContext.createConvolver();
                reverbNode.buffer = this.createReverbImpulseResponse();
                
                this.masterInput.connect(this.reverbWetGain);
                this.reverbWetGain.connect(reverbNode);
                reverbNode.connect(this.audioContext.destination);

                // Create a reusable white noise buffer for the impact sound
                this.noiseBuffer = this.createNoiseBuffer();
                
                // Handle audio context state changes
                this.audioContext.addEventListener('statechange', () => {
                    console.log('Audio context state:', this.audioContext.state);
                });
            }

            initTimeline() {
                const timeline = document.getElementById('timeline');
                const timelineGrid = document.getElementById('timelineGrid');
                
                // Create beat divisions with 16th note subdivisions
                for (let beat = 0; beat < this.beatsPerLoop; beat++) {
                    const beatDiv = document.createElement('div');
                    beatDiv.className = 'timeline-beat';
                    beatDiv.innerHTML = `<div class="timeline-beat-number">${beat + 1}</div>`;
                    
                    // Add 16 subdivisions per beat
                    for (let sub = 0; sub < this.subdivisionsPerBeat; sub++) {
                        const subDiv = document.createElement('div');
                        subDiv.className = 'timeline-subdivision';
                        beatDiv.appendChild(subDiv);
                    }
                    
                    timelineGrid.appendChild(beatDiv);
                }
                
                // Add click handler for placing droplets
                timeline.addEventListener('click', (e) => {
                    if (this.isDraggingMarker) return; // Don't allow placement while dragging markers
                    
                    const rect = timeline.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    
                    // Calculate position with better precision
                    const normalizedX = x / rect.width;
                    const position = Math.floor(normalizedX * this.totalPositions);
                    
                    // Ensure position is within bounds
                    const clampedPosition = Math.max(0, Math.min(position, this.totalPositions - 1));
                    
                    this.addDroplet(clampedPosition);
                });
            }

            initBasin() {
                this.basin = document.getElementById('basin');
                this.basinCenter = { x: 240, y: 240 }; // Half of 480px basin

                this.basin.addEventListener('click', (e) => {
                    // Don't create a new droplet if clicking on an existing one
                    if (e.target.classList.contains('droplet')) {
                        return;
                    }

                    const rect = this.basin.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickY = e.clientY - rect.top;

                    // Coordinates relative to basin center
                    let x = clickX - this.basinCenter.x;
                    let y = clickY - this.basinCenter.y;

                    // Constrain to basin circle
                    const distance = Math.sqrt(x * x + y * y);
                    const maxDistance = this.basinCenter.x - 7.5; // Basin radius minus droplet radius

                    if (distance > maxDistance) {
                        const angle = Math.atan2(y, x);
                        x = Math.cos(angle) * maxDistance;
                        y = Math.sin(angle) * maxDistance;
                    }

                    const position = this.isPlaying ? this.currentPosition : 0;
                    this.addDroplet(position, x, y);
                });
            }

            initControls() {
                const playButton = document.getElementById('playButton');
                playButton.addEventListener('click', () => {
                    // Ensure audio context is running (required for some browsers)
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    if (this.isPlaying) {
                        this.stop();
                    } else {
                        this.play();
                    }
                });

                const caveModeButton = document.getElementById('caveModeButton');
                caveModeButton.addEventListener('click', () => {
                    this.toggleCaveMode();
                });
                
                // Add spacebar controls
                document.addEventListener('keydown', (e) => {
                    // Only respond to spacebar and prevent default behavior
                    if (e.code === 'Space') {
                        e.preventDefault(); // Prevent page scrolling
                        
                        // Ensure audio context is running (required for some browsers)
                        if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                        
                        if (this.isPlaying) {
                            this.stop();
                        } else {
                            this.play();
                        }
                    }
                    
                    // Undo functionality with Command+Z (Mac) or Ctrl+Z (Windows/Linux)
                    if ((e.metaKey || e.ctrlKey) && e.code === 'KeyZ') {
                        e.preventDefault();
                        this.undo();
                    }
                });
                
                // Clear highlighting when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('droplet') && 
                        !e.target.classList.contains('droplet-marker') &&
                        !e.target.closest('#parameterMenu') &&
                        !e.target.closest('#timeline')) {
                        this.clearAllHighlighting();
                    }
                });
                
                this.initParameterMenu();
            }

            initParameterMenu() {
                const menu = document.getElementById('parameterMenu');
                const closeBtn = document.getElementById('menuClose');
                const velocitySlider = document.getElementById('velocitySlider');
                const velocityDisplay = document.getElementById('velocityDisplay');
                const repeatSelect = document.getElementById('repeatSelect');
                const customRepeatGroup = document.getElementById('customRepeatGroup');
                const customRepeatInput = document.getElementById('customRepeatInput');
                
                // Close menu
                closeBtn.addEventListener('click', () => {
                    menu.classList.remove('visible');
                });
                
                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!menu.contains(e.target) && !e.target.classList.contains('droplet')) {
                        menu.classList.remove('visible');
                    }
                });
                
                // Velocity slider
                velocitySlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    velocityDisplay.textContent = `${Math.round(value * 100)}%`;
                    
                    if (this.selectedDroplet) {
                        this.selectedDroplet.velocity = value;
                    }
                });
                
                // Repeat pattern select
                repeatSelect.addEventListener('change', (e) => {
                    const value = e.target.value;
                    customRepeatGroup.style.display = value === 'custom' ? 'block' : 'none';
                    
                    if (this.selectedDroplet) {
                        this.selectedDroplet.repeatPattern = value;
                        this.updateGhostMarkers(this.selectedDroplet);
                    }
                });
                
                // Custom repeat input
                customRepeatInput.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    if (this.selectedDroplet) {
                        this.selectedDroplet.customRepeat = value;
                        this.updateGhostMarkers(this.selectedDroplet);
                    }
                });
            }

            addDroplet(position, basinX = 0, basinY = 0) {
                // Create timeline marker
                const timeline = document.getElementById('timeline');
                const marker = document.createElement('div');
                marker.className = 'droplet-marker';
                marker.style.left = `${((position + 0.5) / this.totalPositions) * 100}%`;
                timeline.appendChild(marker);
                
                // Create basin droplet
                const droplet = document.createElement('div');
                droplet.className = 'droplet';
                droplet.style.left = `${this.basinCenter.x + basinX}px`;
                droplet.style.top = `${this.basinCenter.y + basinY}px`;
                
                // Generate unique ID for this droplet
                const dropletId = this.generateDropletId();
                
                // Store droplet data
                const dropletData = {
                    id: dropletId,
                    position: position,
                    element: droplet,
                    marker: marker,
                    ghostMarkers: [],
                    x: basinX,
                    y: basinY,
                    pitch: 0,
                    velocity: 0.7,
                    repeatPattern: 'none',
                    customRepeat: 4
                };

                // Calculate pitch based on distance from center
                const distance = Math.sqrt(basinX * basinX + basinY * basinY);
                const maxDistance = this.basinCenter.x - 7.5;
                dropletData.pitch = Math.min(distance / maxDistance, 1);
                
                this.droplets.push(dropletData);
                this.basin.appendChild(droplet);
                
                // Add drag functionality
                this.makeDropletDraggable(droplet, dropletData);
                
                // Add timeline marker drag functionality
                this.makeTimelineMarkerDraggable(marker, dropletData);
                
                // Create initial ghost markers
                this.updateGhostMarkers(dropletData);
                
                // Add to history for undo
                this.addToHistory({
                    type: 'addDroplet',
                    dropletId: dropletId
                });
                
                // Highlight the newly created marker and droplet
                console.log('Adding highlighting for new droplet:', dropletData.id); // Debug log
                this.highlightConnection(dropletData);
                console.log('Highlighting added for new droplet'); // Debug log
            }

            makeDropletDraggable(droplet, dropletData) {
                let isDragging = false;
                let startX, startY;
                let hasMoved = false;
                
                droplet.addEventListener('mousedown', (e) => {
                    // Allow dragging even while playing for real-time pitch changes
                    isDragging = true;
                    hasMoved = false;
                    
                    // Highlight the connection when starting to drag
                    this.highlightConnection(dropletData);
                    
                    // Get the current position of the droplet relative to the basin
                    const rect = this.basin.getBoundingClientRect();
                    const dropletRect = droplet.getBoundingClientRect();
                    
                    // Calculate current droplet position relative to basin center
                    const currentX = (dropletRect.left + dropletRect.width / 2) - (rect.left + rect.width / 2);
                    const currentY = (dropletRect.top + dropletRect.height / 2) - (rect.top + rect.height / 2);
                    
                    // Set the starting position to the current droplet position
                    startX = currentX;
                    startY = currentY;
                    
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const rect = this.basin.getBoundingClientRect();
                    const mouseX = e.clientX - (rect.left + rect.width / 2);
                    const mouseY = e.clientY - (rect.top + rect.height / 2);
                    
                    // Only start moving after a small threshold to prevent accidental jumps
                    const moveThreshold = 5;
                    const distanceMoved = Math.sqrt(
                        Math.pow(mouseX - startX, 2) + Math.pow(mouseY - startY, 2)
                    );
                    
                    if (!hasMoved && distanceMoved < moveThreshold) {
                        return;
                    }
                    
                    hasMoved = true;
                    
                    // Constrain to basin circle
                    const distance = Math.sqrt(mouseX * mouseX + mouseY * mouseY);
                    const maxDistance = 232.5; // Basin radius (240) minus droplet radius (7.5)
                    
                    if (distance > maxDistance) {
                        const angle = Math.atan2(mouseY, mouseX);
                        dropletData.x = Math.cos(angle) * maxDistance;
                        dropletData.y = Math.sin(angle) * maxDistance;
                    } else {
                        dropletData.x = mouseX;
                        dropletData.y = mouseY;
                    }
                    
                    // Update visual position
                    droplet.style.left = `${this.basinCenter.x + dropletData.x}px`;
                    droplet.style.top = `${this.basinCenter.y + dropletData.y}px`;
                    
                    // Calculate pitch based on distance from center
                    const normalizedDistance = Math.min(distance / maxDistance, 1);
                    dropletData.pitch = normalizedDistance;
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                // Add click handler for parameter menu
                droplet.addEventListener('click', (e) => {
                    if (isDragging || hasMoved) return; // Don't show menu if we were dragging
                    
                    // Highlight the connection
                    this.highlightConnection(dropletData);
                    
                    // Show parameter menu even during playback
                    this.showParameterMenu(dropletData);
                    e.stopPropagation();
                });
            }

            makeTimelineMarkerDraggable(marker, dropletData) {
                let isDragging = false;
                let startPosition;
                let handleMouseMove, handleMouseUp;
                let hasMoved = false;
                
                const startDrag = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    // Start with highlighting (will be cancelled if we drag)
                    this.highlightConnection(dropletData);
                    
                    isDragging = true;
                    hasMoved = false;
                    this.isDraggingMarker = true;
                    startPosition = dropletData.position;
                    
                    // Add a temporary overlay to prevent timeline clicks
                    const overlay = document.createElement('div');
                    overlay.style.position = 'fixed';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.width = '100%';
                    overlay.style.height = '100%';
                    overlay.style.zIndex = '9999';
                    overlay.style.background = 'transparent';
                    overlay.id = 'dragOverlay';
                    document.body.appendChild(overlay);
                    
                    // Define event handlers
                    handleMouseMove = (e) => {
                        if (!isDragging) return;
                        
                        // Keep the highlighting during drag (don't clear it)
                        // The highlighting shows the connection even while dragging
                        
                        const timeline = document.getElementById('timeline');
                        const rect = timeline.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        
                        // Snap to grid positions (0-63) - this creates the "jumping" effect
                        const gridPosition = Math.floor((mouseX / rect.width) * this.totalPositions);
                        const snappedPosition = Math.max(0, Math.min(this.totalPositions - 1, gridPosition));
                        
                        // Update marker position - this will "jump" to grid positions
                        const snappedLeftPercent = ((snappedPosition + 0.5) / this.totalPositions) * 100;
                        marker.style.left = `${snappedLeftPercent}%`;
                        
                        // Update droplet data
                        dropletData.position = snappedPosition;
                        
                        // Update ghost markers
                        this.updateGhostMarkers(dropletData);
                    };
                    
                    handleMouseUp = (e) => {
                        if (!isDragging) return;
                        
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        
                        // Remove overlay
                        const overlay = document.getElementById('dragOverlay');
                        if (overlay) {
                            overlay.remove();
                        }
                        
                        // Reset states
                        isDragging = false;
                        this.isDraggingMarker = false;
                        
                        // Add to history for undo only if the marker was actually moved
                        if (hasMoved) {
                            this.addToHistory({
                                type: 'moveDroplet',
                                dropletId: dropletData.id,
                                oldPosition: startPosition
                            });
                        }
                        
                        // Remove event listeners
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    };
                    
                    // Add event listeners
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                };
                
                // Add the mousedown listener to the marker
                marker.addEventListener('mousedown', startDrag);

                // Add a separate click handler for opening the parameter menu
                marker.addEventListener('click', (e) => {
                    // If the marker was dragged, don't open the menu
                    if (hasMoved) {
                        return;
                    }
                    
                    // Open the parameter menu
                    this.highlightConnection(dropletData);
                    this.showParameterMenu(dropletData);
                    e.stopPropagation();
                });
            }

            play() {
                if (this.isPlaying) return;
                
                console.log('Play function called'); // Debug log
                
                // Resume audio context if it's suspended (required for some browsers)
                if (this.audioContext.state === 'suspended') {
                    console.log('Resuming audio context'); // Debug log
                    this.audioContext.resume();
                }
                
                this.isPlaying = true;
                this.currentPosition = 0;
                
                // Start immediately
                this.nextNoteTime = this.audioContext.currentTime;
                
                const playButton = document.getElementById('playButton');
                playButton.textContent = 'Stop';
                playButton.classList.add('playing');
                
                console.log('Starting scheduler'); // Debug log
                // Use a more precise timing method
                this.scheduleNextNote();
            }

            scheduleNextNote() {
                if (!this.isPlaying) return;
                
                const now = this.audioContext.currentTime;
                const beatTime = 60.0 / this.bpm; // Time for one beat
                const sixteenthNoteTime = beatTime / this.subdivisionsPerBeat; // Time for one 16th note
                
                // Schedule the current note
                if (now >= this.nextNoteTime) {
                    console.log('Playing beat at position:', this.currentPosition); // Debug log
                    this.playBeat(this.currentPosition);
                    this.currentPosition = (this.currentPosition + 1) % this.totalPositions;
                    this.nextNoteTime += sixteenthNoteTime;
                }
                
                // Schedule the next check
                this.scheduler = setTimeout(() => {
                    this.scheduleNextNote();
                }, 10); // Check every 10ms for precision
            }

            stop() {
                this.isPlaying = false;
                clearTimeout(this.scheduler);
                
                const playButton = document.getElementById('playButton');
                playButton.textContent = 'Play';
                playButton.classList.remove('playing');
                
                // Remove active beat highlighting
                document.querySelectorAll('.timeline-beat').forEach(beat => {
                    beat.classList.remove('active');
                });
                
                // Remove active subdivision highlighting
                document.querySelectorAll('.timeline-subdivision').forEach(sub => {
                    sub.classList.remove('active');
                });
            }

            playBeat(position) {
                const beatIndex = Math.floor(position / this.subdivisionsPerBeat);
                const subIndex = position % this.subdivisionsPerBeat;
                
                // Highlight current beat
                document.querySelectorAll('.timeline-beat').forEach((beat, index) => {
                    beat.classList.toggle('active', index === beatIndex);
                });
                
                // Highlight current subdivision
                document.querySelectorAll('.timeline-subdivision').forEach((sub, index) => {
                    const subBeatIndex = Math.floor(index / this.subdivisionsPerBeat);
                    const subSubIndex = index % this.subdivisionsPerBeat;
                    sub.classList.toggle('active', subBeatIndex === beatIndex && subSubIndex === subIndex);
                });
                
                // Play droplets on this position
                this.droplets.forEach(droplet => {
                    if (this.shouldDropletPlay(droplet, position)) {
                        this.playDropletSound(droplet);
                        this.createBasinRipple(droplet);
                    }
                });
            }

            shouldDropletPlay(droplet, position) {
                // Check if this is the original position
                if (droplet.position === position) {
                    return true;
                }
                
                // Check repeat patterns
                if (droplet.repeatPattern === 'none') {
                    return false;
                }
                
                const originalBeat = Math.floor(droplet.position / this.subdivisionsPerBeat);
                const currentBeat = Math.floor(position / this.subdivisionsPerBeat);
                const originalSub = droplet.position % this.subdivisionsPerBeat;
                const currentSub = position % this.subdivisionsPerBeat;
                
                // Must be on the same subdivision within the beat
                if (originalSub !== currentSub) {
                    return false;
                }
                
                // Check repeat interval
                let repeatInterval;
                switch (droplet.repeatPattern) {
                    case 'every-beat':
                        repeatInterval = 1;
                        break;
                    case 'every-2-beats':
                        repeatInterval = 2;
                        break;
                    case 'every-4-beats':
                        repeatInterval = 4;
                        break;
                    case 'custom':
                        repeatInterval = droplet.customRepeat;
                        break;
                    default:
                        return false;
                }
                
                // Check if current beat is a repeat of the original
                const beatDifference = currentBeat - originalBeat;
                if (beatDifference <= 0) {
                    return false; // Only repeat forward in time
                }
                
                return beatDifference % repeatInterval === 0;
            }

            playDropletSound(droplet) {
                const now = this.audioContext.currentTime;

                // --- Create Impact Sound (Noise Burst) ---
                const noiseSource = this.audioContext.createBufferSource();
                noiseSource.buffer = this.noiseBuffer;
                const noiseGain = this.audioContext.createGain();
                noiseSource.connect(noiseGain);
                noiseGain.connect(this.masterInput);

                // --- Create Resonance Sound (Tonal Plink) ---
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();

                // Connect nodes: oscillator -> filter -> gain -> masterInput
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.masterInput);

                // --- Configure Oscillator (Pitch) ---
                const baseFreq = 100;
                const maxFreq = 2000;
                const startFreq = baseFreq + (droplet.pitch * (maxFreq - baseFreq));
                const endFreq = startFreq * 2;
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(startFreq, now);
                oscillator.frequency.exponentialRampToValueAtTime(endFreq, now + 0.05);

                // --- Configure Filter (Timbre) ---
                filter.type = 'lowpass';
                filter.Q.value = 20; // High resonance for a "plink" sound
                
                // The filter sweep creates the percussive sound
                const filterStartFreq = endFreq * 1.5;
                const filterEndFreq = startFreq * 0.5;

                filter.frequency.setValueAtTime(filterStartFreq, now);
                filter.frequency.exponentialRampToValueAtTime(filterEndFreq, now + 0.08);

                // --- Configure Envelopes ---
                // Impact sound envelope (very short and sharp)
                const impactVolume = 0.1 * droplet.velocity;
                noiseGain.gain.setValueAtTime(0, now);
                noiseGain.gain.linearRampToValueAtTime(impactVolume, now + 0.005);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);

                // Resonance sound envelope
                const maxVolume = 0.3 * droplet.velocity;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(maxVolume, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                // --- Start and Stop Sounds ---
                noiseSource.start(now);
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }

            createBasinRipple(dropletData) {
                const rippleCount = 5;
                const totalDuration = 1200; // Corresponds to animation-duration in CSS
                const stagger = 150; // ms

                const x = this.basinCenter.x + dropletData.x;
                const y = this.basinCenter.y + dropletData.y;

                for (let i = 0; i < rippleCount; i++) {
                    const ripple = document.createElement('div');
                    ripple.className = 'basin-ripple';

                    ripple.style.left = `${x}px`;
                    ripple.style.top = `${y}px`;

                    // Stagger the animation start time
                    ripple.style.animationDelay = `${i * stagger}ms`;

                    // Dim the outer ripples to match the sketch
                    ripple.style.opacity = (1 - (i / rippleCount)) * 0.3;

                    this.basin.appendChild(ripple);

                    // Remove the ripple from the DOM after its animation is complete
                    setTimeout(() => {
                        ripple.remove();
                    }, totalDuration + (i * stagger));
                }
            }

            showParameterMenu(dropletData) {
                this.selectedDroplet = dropletData;
                
                const menu = document.getElementById('parameterMenu');
                const velocitySlider = document.getElementById('velocitySlider');
                const velocityDisplay = document.getElementById('velocityDisplay');
                const repeatSelect = document.getElementById('repeatSelect');
                const customRepeatGroup = document.getElementById('customRepeatGroup');
                const customRepeatInput = document.getElementById('customRepeatInput');
                
                // Populate menu with current values
                velocitySlider.value = dropletData.velocity;
                velocityDisplay.textContent = `${Math.round(dropletData.velocity * 100)}%`;
                repeatSelect.value = dropletData.repeatPattern;
                customRepeatInput.value = dropletData.customRepeat;
                customRepeatGroup.style.display = dropletData.repeatPattern === 'custom' ? 'block' : 'none';
                
                // Show menu
                menu.classList.add('visible');
            }

            updateGhostMarkers(dropletData) {
                // Remove existing ghost markers
                dropletData.ghostMarkers.forEach(marker => {
                    if (marker.parentNode) {
                        marker.parentNode.removeChild(marker);
                    }
                });
                dropletData.ghostMarkers = [];
                
                // Don't create ghosts if no repeat pattern
                if (dropletData.repeatPattern === 'none') {
                    return;
                }
                
                const timeline = document.getElementById('timeline');
                const originalBeat = Math.floor(dropletData.position / this.subdivisionsPerBeat);
                const originalSub = dropletData.position % this.subdivisionsPerBeat;
                
                // Calculate repeat interval
                let repeatInterval;
                switch (dropletData.repeatPattern) {
                    case 'every-beat':
                        repeatInterval = 1;
                        break;
                    case 'every-2-beats':
                        repeatInterval = 2;
                        break;
                    case 'every-4-beats':
                        repeatInterval = 4;
                        break;
                    case 'custom':
                        repeatInterval = dropletData.customRepeat;
                        break;
                    default:
                        return;
                }
                
                // Create ghost markers for all repeats within the loop
                let i = 1;
                while (true) {
                    const repeatBeat = originalBeat + (i * repeatInterval);
                    
                    // Stop when we exceed the loop length
                    if (repeatBeat >= this.beatsPerLoop) {
                        break;
                    }
                    
                    const repeatPosition = (repeatBeat * this.subdivisionsPerBeat) + originalSub;
                    
                    const ghostMarker = document.createElement('div');
                    ghostMarker.className = 'ghost-marker';
                    ghostMarker.style.left = `${((repeatPosition + 0.5) / this.totalPositions) * 100}%`;
                    timeline.appendChild(ghostMarker);
                    
                    dropletData.ghostMarkers.push(ghostMarker);
                    i++;
                }
            }

            // Add action to history
            addToHistory(action) {
                this.actionHistory.push(action);
                
                // Limit history size
                if (this.actionHistory.length > this.maxHistorySize) {
                    this.actionHistory.shift();
                }
            }

            // Undo last action
            undo() {
                if (this.actionHistory.length === 0) return;
                
                const lastAction = this.actionHistory.pop();
                
                switch (lastAction.type) {
                    case 'addDroplet':
                        this.removeDroplet(lastAction.dropletId);
                        break;
                    case 'removeDroplet':
                        this.restoreDroplet(lastAction.dropletData);
                        break;
                    case 'moveDroplet':
                        this.moveDropletToPosition(lastAction.dropletId, lastAction.oldPosition);
                        break;
                    case 'changeParameter':
                        this.restoreDropletParameter(lastAction.dropletId, lastAction.parameter, lastAction.oldValue);
                        break;
                }
            }

            // Generate unique ID for droplets
            generateDropletId() {
                return Date.now() + Math.random().toString(36).substr(2, 9);
            }

            // Remove droplet by ID
            removeDroplet(dropletId) {
                const dropletIndex = this.droplets.findIndex(d => d.id === dropletId);
                if (dropletIndex === -1) return;
                
                const droplet = this.droplets[dropletIndex];
                
                // Remove from DOM
                if (droplet.element.parentNode) {
                    droplet.element.parentNode.removeChild(droplet.element);
                }
                if (droplet.marker.parentNode) {
                    droplet.marker.parentNode.removeChild(droplet.marker);
                }
                
                // Remove ghost markers
                droplet.ghostMarkers.forEach(marker => {
                    if (marker.parentNode) {
                        marker.parentNode.removeChild(marker);
                    }
                });
                
                // Remove from array
                this.droplets.splice(dropletIndex, 1);
            }

            // Restore droplet from saved data
            restoreDroplet(dropletData) {
                // Recreate timeline marker
                const timeline = document.getElementById('timeline');
                const marker = document.createElement('div');
                marker.className = 'droplet-marker';
                marker.style.left = `${((dropletData.position + 0.5) / this.totalPositions) * 100}%`;
                timeline.appendChild(marker);
                
                // Recreate basin droplet
                const droplet = document.createElement('div');
                droplet.className = 'droplet';
                droplet.style.left = `${this.basinCenter.x + dropletData.x}px`;
                droplet.style.top = `${this.basinCenter.y + dropletData.y}px`;
                
                // Create new droplet data
                const newDropletData = {
                    ...dropletData,
                    element: droplet,
                    marker: marker,
                    ghostMarkers: []
                };
                
                this.droplets.push(newDropletData);
                this.basin.appendChild(droplet);
                
                // Add drag functionality
                this.makeDropletDraggable(droplet, newDropletData);
                
                // Recreate ghost markers
                this.updateGhostMarkers(newDropletData);
            }

            // Move droplet to specific position
            moveDropletToPosition(dropletId, position) {
                const droplet = this.droplets.find(d => d.id === dropletId);
                if (!droplet) return;
                
                // Update position
                droplet.position = position;
                
                // Update marker position
                droplet.marker.style.left = `${((position + 0.5) / this.totalPositions) * 100}%`;
                
                // Update ghost markers
                this.updateGhostMarkers(droplet);
            }

            // Restore droplet parameter
            restoreDropletParameter(dropletId, parameter, value) {
                const droplet = this.droplets.find(d => d.id === dropletId);
                if (!droplet) return;
                
                droplet[parameter] = value;
                
                if (parameter === 'repeatPattern' || parameter === 'customRepeat') {
                    this.updateGhostMarkers(droplet);
                }
            }

            // Highlight connection between marker and droplet
            highlightConnection(dropletData) {
                console.log('highlightConnection called for droplet:', dropletData.id); // Debug log
                
                this.clearAllHighlighting();
                
                // Highlight the corresponding droplet
                if (dropletData.marker) {
                    dropletData.marker.classList.add('selected');
                    console.log('Added selected class to marker'); // Debug log
                }
                if (dropletData.element) {
                    dropletData.element.classList.add('selected');
                    console.log('Added selected class to droplet'); // Debug log
                }
                
                console.log('highlightConnection completed'); // Debug log
            }

            // Clear all highlighting
            clearAllHighlighting() {
                document.querySelectorAll('.droplet-marker').forEach(marker => {
                    marker.classList.remove('selected');
                });
                document.querySelectorAll('.droplet').forEach(droplet => {
                    droplet.classList.remove('selected');
                });
            }

            toggleCaveMode() {
                console.log('toggleCaveMode called'); // Debug log
                this.isCaveMode = !this.isCaveMode;
                console.log('Cave mode is now:', this.isCaveMode); // Debug log

                const caveModeButton = document.getElementById('caveModeButton');
                caveModeButton.classList.toggle('active', this.isCaveMode);

                // Smoothly fade reverb in/out
                const now = this.audioContext.currentTime;
                const targetVolume = this.isCaveMode ? 0.3 : 0.0;
                console.log('Setting reverb volume to:', targetVolume); // Debug log
                this.reverbWetGain.gain.linearRampToValueAtTime(targetVolume, now + 0.5);
            }
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new DripDrip();
        });
    </script>
</body>
</html> 
